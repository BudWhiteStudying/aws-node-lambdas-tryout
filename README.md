## Hot reload on AWS Node Lambdas

### Project structure
The idea is to have a single SAM wrapper project containing one or more Node Lambdas. At the root of the project we have the `template.yaml`
file describing the whole application, and the `.aws-sam` directory which is automatically generated by the `sam build` command (see below).

Each Lambda Function is then contained in its own directory, and constitutes a separate Node project (and also a separate Typescript project).
```
├─ .aws-sam
├─ template.yaml
├─ hello-function-1
│  ├─ src
│  │  └─ index.ts
│  ├─ output
│  │  └─ index.js
│  ├─ package.json
│  ├─ tsconfig.json
│  └─ node_modules
└─ hello-function-2
   ├─ src
   │  └─ index.ts
   ├─ output
   │  └─ index.js
   ├─ package.json
   ├─ tsconfig.json
   └─ node_modules
```

### The `template.yaml` file
The `template.yaml` file looks like this:
```
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Sample set of NodeJS functions

# Enabling CORS just in case (this is bad for production)
Globals:
  Function:
    Timeout: 20
  Api:
    Cors:
      AllowCredentials: false
      AllowHeaders: "'*'"
      AllowMethods: "'GET,PUT,POST'"
      AllowOrigin: "'*'"

Resources:
  MyFunction1:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: hello-function-1
      Handler: output/index.handler
      Runtime: nodejs12.x
      MemorySize: 512
      Environment: # More info about Env Vars: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#environment-object
        Variables:
          PARAM1: VALUE
      Events:
        Characters:
          Type: Api # More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api
          Properties:
            Path: /hello1
            Method: get
  MyFunction2:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: hello-function-2
      Handler: output/index.handler
      Runtime: nodejs12.x
      MemorySize: 512
      Environment: # More info about Env Vars: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#environment-object
        Variables:
          PARAM1: VALUE
      Events:
        Characters:
          Type: Api # More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api
          Properties:
            Path: /hello2
            Method: get

Outputs:
  # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function
  # Find out more about other implicit resources you can reference within SAM
  # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api
  Hello1Api:
    Description: "API Gateway endpoint URL for Prod stage for Hello 1 function"
    Value: !Sub "https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/hello1/"
  Hello1Function:
    Description: "Tryout Lambda Function ARN"
    Value: !GetAtt Hello1Function.Arn
  Hello1FunctionIamRole:
    Description: "Implicit IAM Role created for Hello 1 function"
    Value: !GetAtt Hello1FunctionRole.Arn
  Hello2Api:
    Description: "API Gateway endpoint URL for Prod stage for Hello 2 function"
    Value: !Sub "https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/hello2/"
  Hello2Function:
    Description: "Tryout Lambda Function ARN"
    Value: !GetAtt Hello2Function.Arn
  Hello2FunctionIamRole:
    Description: "Implicit IAM Role created for Hello 2 function"
    Value: !GetAtt Hello2FunctionRole.Arn

```
It declares (among all things):
- global properties that apply to all functions (in this case I set extra-permissive CORS headers on all resources that will be exposed by the API Gateway)
- a resource for each Lambda Function; within each resource the `CodeUri` property indicates the location of the root folder for the function, while the
`Handler` property indicates, from the root folder, the location of the source code for the function (i.e. the handler code)
- the desired output of a SAM deployment, in this case REST resources exposed through an API Gateway and mapping to Lambda Functions, and the necessary IAM
roles to make them work within the authorization framework of AWS

### The `tsconfig.json` file

The `tsconfig.json` file looks like this:
```
{
  "compilerOptions": {
    "target": "es5",                          /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    "module": "commonjs",                     /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    "outDir": "./output",                     /* Redirect output structure to the directory. */
    "rootDir": "./src",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */

    /* Strict Type-Checking Options */
    "strict": true,                           /* Enable all strict type-checking options. */
    "esModuleInterop": true,                  /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */

    /* Advanced Options */
    "forceConsistentCasingInFileNames": true  /* Disallow inconsistently-cased references to the same file. */
  },

  // NEW: Options for file/directory watching
  "watchOptions": {
    // Use native file system events for files and directories
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    // Poll files for updates more frequently
    // when they're updated a lot.
    "fallbackPolling": "dynamicPriority",
    // Don't coalesce watch notification
    "synchronousWatchDirectory": true,
    // Finally, two additional settings for reducing the amount of possible
    // files to track  work from these directories - these two properties seem to be unknown
    //"excludeDirectories": ["node_modules"],
    //"excludeFiles": []
  }
}
```
Pretty standard, the most interesting bit being the `watchOptions` section, that tells `tsc` to look for changes in `.ts` files, and transpile them right away
as soon as they change. I have yet to find a way to exclude directories.

### Structure of each function
In this extremely basic case the `src` and the `output` directories have only 1 file each. The `index.ts` file, which is the actual source code containing the handler function, is of course located in the `src` folder. When transpiling, `tsc` generates the `index.js` file in the `output` directory, as instructed by the `outDir` property of the `tsconfig.json` file.

### Hot reload
Finally, hot reload is obtained through the following steps:
1. in a separate Terminal window for each function, get to the root of the function directory (where the `tsconfig.json` file is located) and run `tsc --watch`
2. in another separate Terminal window, get to the root of the whole project (where the `template.yaml` file is located) and run `nodemon --exec sam build`
3. finally, in yet another separate Terminal window, get to the root of the whole project (where the `template.yaml` file is located) and run `sam local start-api`

Each time a `.ts` file is updated, `tsc` will immediately transpile it into a fresh `.js` file; each time this happens, `nodemon` will notice the change and will trigger a new `sam build`; the `sam local start-api` will then serve the updated content, since a `sam build` was triggered.

### Next steps
This is clearly a rough method, probably burning a LOT of resources for a rather simple task. It could be worthwhile experimenting with Webpack instead of using
nodemon.